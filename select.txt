/*1.1	
Выбрать из таблицы Orders заказы, которые были доставлены после 5 мая 1998 года (колонка shippedDate) включительно и которые доставлены с shipVia >= 2. 
Формат указания даты должен быть верным при любых региональных настройках. 
Этот метод использовать далее для всех заданий. 
Запрос должен выбирать только колонки orderID, shippedDate и shipVia. 
Пояснить, почему сюда не попали заказы с NULL-ом в колонке shippedDate. */

SELECT OrderID, ShippedDate, ShipVia
FROM ORDERS 
WHERE TO_DATE(TO_CHAR(ShippedDate,'DD.MM.YYYY'),'DD.MM.YYYY')>=TO_DATE('05.05.1998', 'DD.MM.YYYY') AND ShipVia>=2;

/*1.2	
Написать запрос, который выводит только недоставленные заказы из таблицы Orders. 
В результатах запроса высвечивать для колонки shippedDate вместо значений NULL строку ‘Not Shipped’ – необходимо использовать CASЕ выражение. 
Запрос должен выбирать только колонки orderID и shippedDate.*/

SELECT OrderID, 
CASE 
WHEN ShippedDate IS NULL THEN 'Not Shipped'
ELSE TO_CHAR(ShippedDate)
END
FROM ORDERS 
WHERE ShippedDate IS NULL;

/*1.3	
Выбрать из таблици Orders заказы, которые были доставлены после 5 мая 1998 года (shippedDate), не включая эту дату, или которые еще не доставлены. 
Запрос должен выбирать только колонки orderID (переименовать в Order Number) и shippedDate (переименовать в Shipped Date). 
В результатах запроса  для колонки shippedDate вместо значений NULL выводить строку ‘Not Shipped’ (необходимо использовать функцию NVL), для остальных значений высвечивать дату в формате “ДД.ММ.ГГГГ”.
*/

ALTER TABLE Orders
RENAME COLUMN OrderID TO "Order Number";

ALTER TABLE Orders
RENAME COLUMN ShippedDate TO "Shipped Date";

SELECT "Order Number", NVL(TO_CHAR("Shipped Date",'DD.MM.YYYY'),'Not Shipped')
FROM ORDERS
WHERE ("Shipped Date" IS NULL) OR (TO_DATE(TO_CHAR("Shipped Date",'DD.MM.YYYY'),'DD.MM.YYYY')>TO_DATE('05.05.1998', 'DD.MM.YYYY'));

/*2.1
Выбрать из таблицы Customers всех заказчиков, проживающих в USA или Canada. 
Запрос сделать с только помощью оператора IN. 
Запрос должен выбирать колонки с именем пользователя и названием страны. 
Упорядочить результаты запроса по имени заказчиков и по месту проживания.
*/

SELECT ContactName, Country
FROM Customers
WHERE Country IN ('USA','Canada')
ORDER BY ContactName, Country;

/*2.2
Выбрать из таблицы Customers всех заказчиков, не проживающих в USA и Canada. 
Запрос сделать с помощью оператора IN. 
Запрос должен выбирать колонки с именем пользователя и названием страны а. 
Упорядочить результаты запроса по имени заказчиков в порядке убывания.
*/

SELECT ContactName, Country
FROM Customers
WHERE NOT Country IN ('USA','Canada')
ORDER BY ContactName DESC;

/*2.3
Выбрать из таблицы Customers все страны, в которых проживают заказчики. 
Страна должна быть упомянута только один раз, Результат должен быть отсортирован по убыванию. 
Не использовать предложение GROUP BY.  
*/

SELECT DISTINCT Country
FROM Customers
ORDER BY Country DESC;

/*3.1
Выбрать все заказы из таблицы Order_Details (заказы не должны повторяться), где встречаются продукты с количеством от 3 до 10 включительно – это колонка Quantity в таблице Order_Details. 
Использовать оператор BETWEEN. 
Запрос должен выбирать только колонку идентификаторы заказов.
*/

SELECT DISTINCT OrderId
FROM Order_Details
WHERE Quantity BETWEEN 3 AND 10;

/*3.2
Выбрать всех заказчиков из таблицы Customers, у которых название страны начинается на буквы из диапазона B и G. 
Использовать оператор BETWEEN. 
Проверить, что в результаты запроса попадает Germany. 
Запрос должен выбирать только колонки сustomerID  и сountry. 
Результат должен быть отсортирован по значению столбца сountry
*/

SELECT CustomerID, Country
FROM Customers
WHERE SUBSTR(Country,0,1) BETWEEN 'B' AND 'G'
ORDER BY Country;

/*3.3
Выбрать всех заказчиков из таблицы Customers, у которых название страны начинается на буквы из диапазона B и G, не используя оператор BETWEEN. 
Запрос должен выбирать только колонки сustomerID  и сountry. 
Результат должен быть отсортирован по значению столбца сountry. 
С помощью опции “Execute Explain Plan” определить какой запрос предпочтительнее 3.2 или 3.3. 
В комментариях к текущему запросу необходимо объяснить результат.
ОТВЕТ: "Execute Explain Plan" - позволяет нам понять каким образом выполняется запрос, какие запрос использует индексы и использует ли их вообще, какие методы доступа применяет оптимизатор Oracle при выполнении SQL запроса.
При рассмотрении зароса 3.2 и 3.3 в планировщике можно заметить что констуркция between эквивалентна записи с AND 
*/

SELECT CustomerID, Country
FROM Customers
WHERE 'B'<=SUBSTR(Country,0,1) AND SUBSTR(Country,0,1)<='G'
ORDER BY Country;

/*4.1	
В таблице Products найти все продукты (колонка productName), где встречается подстрока 'chocolade'. 
Известно, что в подстроке 'chocolade' может быть изменена одна буква 'c' в середине - найти все продукты, которые удовлетворяют этому условию. 
Подсказка: в результате должны быть найдены 2 строки.
*/

SELECT ProductName
FROM Products
WHERE LOWER(ProductName) LIKE ('%cho_olade%');

/*5.1	
Найти общую сумму всех заказов из таблицы Order_Details с учетом количества закупленных товаров и скидок по ним. 
Результат округлить до сотых и отобразить в стиле: $X,XXX.XX, где “$” - валюта доллары, “,” – разделитель групп разрядов, “.” – разделитель целой и дробной части, при этом дробная часть должна содержать цифры до сотых, пример: $1,234.00. 
Скидка (колонка Discount) составляет процент из стоимости для данного товара. Для определения действительной цены на проданный продукт надо вычесть скидку из указанной в колонке unitPrice цены. 
Результатом запроса должна быть одна запись с одной колонкой с названием колонки 'Totals'.
*/

SELECT TO_CHAR(SUM((UnitPrice-UnitPrice*Discount)*Quantity),'$9,999,999.99') AS Totals
FROM Order_Details;

/*5.2
По таблице Orders найти количество заказов, которые еще не были доставлены (т.е. в колонке shippedDate нет значения даты доставки). 
Использовать при этом запросе только оператор COUNT. 
Не использовать предложения WHERE и GROUP.
*/

SELECT COUNT(shippedDate)
FROM Orders;

/*5.3
По таблице Orders найти количество различных покупателей (сustomerID), сделавших заказы. 
Использовать функцию COUNT и не использовать предложения WHERE и GROUP.
*/

SELECT COUNT(DISTINCT customerID)
FROM Orders;


